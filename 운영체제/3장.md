# 3장 프로세스
역사: 초기 컴퓨터는 하나의 프로세스만 실행되도록 허용되었지만 시대가 바뀌면서 병렬 실행을 요구하게 됨

프로세스: 실행 중인 프로그램

스레드: 한 프로세스 내에 있는 실행 흐름
예: 문자를 입력하면서 동시에 철자 검사기를 실행 가능케함

PCB: 프로세스 제어 블록
각 프로세스가 PCB에 의해 표현된다.
상태: new-ready-running-waiting-terminated

스케줄링 큐(잡 큐)
프로세스가 시스템에 들어오면 잡 큐에 놓여진다.
준비 완료 상태에서 실행 대기 프로세스는 준비 완료 큐(ready queue)에 저장됨

1. 스케줄러
1.1. 장기 스케줄러(잡 스케줄러): 디스크에서 프로세스를 선택해 실행하기 위해 메모리 적재, 상대적으로 속도가 느림(초, 분 단위), 현대 에서는 메모리 용량이 커져서 잘 쓰지 않음
1.2. 중기 스케줄러: 메모리에서 프로세스 제거 다중 프로그래밍 정도 완화, 현재 프로세스 PCB에 저장, 중단된 프로세스 문맥 가져와 실행 재개, 문맥 교환(Context switch)가 이뤄짐(8장에서 논의)
1.3. 단기 스케줄러(CPU 스케줄러): 실행 준비가 완료된 프로세스 중 선택해 CPU 할당, ms 단위로 움직여야 됨(5장에서 논의)

프로세스간 통신
1. 공유 메모리: 프로세스끼리 공유되는 메모리 영역있음, 동기화 필요(6장에서 논의)
2. 메시지 전달: 메시지 큐에 쌓아놓고 전달

버퍼링(Buffering)
통신의 직접적이든 간접적이든, 메시지는 임시 큐에 들어있다. 이러한 큐 구현 방식 3가지
1. 무용량: 큐의 길이가 0, 이 경우 송신자(sender)는 수신자(receiever)가 메시지를 수신할 때까지 기다려야 한다.
2. 유햔 용량: 큐가 n의 길이를 가진다. 덕분에 송신자는 대기하지 않고 실행을 계속한다. 큐가 꽉차면 송신자는 공간이 이용 가능할 때까지 기다린다. 예: 유투브 영상 버퍼링
3. 무한 용량: 큐가 무한한 길이를 가진다. 송신자는 결코 봉쇄되지 않는다.