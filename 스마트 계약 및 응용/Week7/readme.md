## 7.1 Security Challenges

블록체인은 버그 하나도 치명적일 수 있다. 실제로 2016년 DAO 해킹에서는 500억 원이 넘는 돈이 위험에 처하기도 했다.

2010년 8월 비트코인 개발자인 Jeff Garzik은 블록의 value out이 이상하다는 짧은 글을 올렸다.

- ![1](./7.1.png)

1. 그는 한 블록이 총 92 빌리언 비트코인을 갖고 있음을 발견했다. 그 당시에 거래되는 비트코인의 총 액수가 3백만 비트코인 밖에 없었던 것을 보면 명백히 잘못된 값이다.

이는 integer overflow 버그 때문에 생긴 것인데 두 정수값의 합이 마이너스가 되는 것을 확인하지 않고 그 결과를 unsigned integer로 취급하니 엄청나게 큰 값이 되어버린 것이다.

비트코인 네트워크는 버그 수정 후에 이전 transaction으로 되돌릴 수 밖에 없었다.

2. 또한 시스템의 업그레이드 때문에 문제가 발생하기도 했다.

2012년 비트코인 core 버전이 0.7에서 0.8로 업그레이드 되었는데 새로운 버전이 이전 버전과 호환되지 않는 문제가 생겨 이전 버전에서 생성되는 블록들이 새로운 버전에는 인식되지 않는 문제가 생겼고 비트코인 네트워크에 두 가지 버전의 비트코인이 생겨나기 시작했다.

결국 비트코인 커뮤니티는 모두가 이전 버전으로 되돌아가기로 결정했고 새로운 버전에서 생성된 블록들은 포기하게 됐다.

새로운 버전에서 채굴에 성공했던 채굴업자들은 손해를 감수하고 이전 버전으로 되돌아가는 것에 동의하면서 문제가 해결됐다.

3. 스마트 컨트랙트의 안전성 문제
   코어 시스템의 경우에는 상대적으로 철저하게 리뷰되고 테스트 되고 있으며 심각한 경우에는 이전 버전으로 되돌리는 방법으로 문제를 해결할 수 있지만, 스마트 컨트랙트는 그렇지 못하다는 문제가 있다.

4. The DAO Hack (2016)
   전통적인 관리조직이나 이사회가 존재하지 않는 투자 신탁.

펀드를 받고자 하는 프로젝트는 proposal을 내게 되는데 프로젝트의 방향성이 변경되거나 새로운 아이디어가 제시되면 이 제안에 반대하는 사람은 그냥 기존 proposal에 남아있고, 찬성하는 사람의 fund만 새로운 주소로 옮겨간다는 구성이다.

이는 다수결의 횡포를 막기 위해서 만들어졌다.
문제는 새로운 주소로 옮겨갈 때 fund를 먼저 보내고 나서 값을 초기화하고 있는데 여기서 만약 문제가 생기면
돈만 보내고 값은 그대로 남는 경우가 발생할 수 있다.

- ![1](./7.1.2.png)

해커들은 앞에서 설명한 버그를 이용한 공격을 시작하였고 500억원이 다른 계정으로 옮겨지는 상황이 발생했다.

이로 인한 피해를 보상하기 위해 이더리움에서는 하드 포크를 통해 투자자의 토큰을 되돌려 주기로 결정한다.
하지만 하드 포크를 반대하는 사람들로 인해 기존 블록체인을 계속 유지하기로 하였고 이더리움은 이더리움 클래식과 이더리움으로 나뉘게 된다.

5. Ethereum Name Service Bug (2017)
   인터넷상의 DNS 서비스와 같이 이더리움의 account address를 쉬운 표기법으로 사용할 수 있게 해주는 서비스이다.

경매 방식을 사용하여 원하는 이름을 사용할 수 있다.

그런데, 2017년 이 서비스가 처음 공개됐을 때 경매가 끝나고 경매에 참여할 수 있는 버그가 발견됐다.

- ![1](./7.1.3.png)

수정전 코드(왼쪽)에서는 경매 기간이 끝났는지를 확인하는 부분이 빠져있었다.

그러나 수정 후의 코드도 문제가 있었는데 \_value, value가 혼동되어 사용되고 있었던 것이다.

- ![1](./7.1.4.png)

6. The Parity wallet exploits
   멀티 시그니쳐를 지원하는 전자 지갑에 버그가 발생했다.

- ![1](./7.1.5.png)
  WalletLibrary의 initWallet은 여러 명의 owner 어드레스를 넘겨 받아서 이 값을 wallet의 주인으로 설정하게 된다.

Wallet에는 fallback 메소드가 있다. 여기에서는 msg.data.length > 0일 때 walletLibrary의 initWallet을 호출하게 된다.

만약 처음에 불린 메소드가 initWallet이라면 Wallet contract에서는 fallback 메소드를 호출하게 되고 다시 delegatecall을 호출하게 되면 initWallet이 호출이 되게 되어서 지갑의 주인을 바꿀 수가 있게 된다.

- ![1](./7.1.6.png)

코드의 이런 문제점은 사진과 같이 초기화가 된 경우에는 다시 초기화 될 수 없도록 조건이 추가되었고 initWallet이 외부에서 호출되지 않도록 internal 키워드를 붙여서 해결하게 됐다.

하지만 이미 위험에 노출된 수많은 wallet 스마트 컨트랙트는 어떻게 됐을까?

해커가 이 버그를 이용해서 이더를 훔쳐간 것과 동일한 방법으로 사용자들의 이더를 안전한 새로운 계정으로 옮겨주었다.

하지만 몇 개월 후 다른 버그 때문에 이 라이브러리를 사용하던 151개의 어드레스가 영향을 받아 이들의 $152 밀리언 달러가 잠겨버리는 일이 발생됐다.한 사용자가 initWallet을 실행시켜서 wallet library의 owner가 되었고 별생각없이 suicide/selfdestruct 명령을 보냈다고 한다.
